/* const_ref.cpp--临时变量、引用参数和const
 * 实参和引用参数不匹配（类型、非左值）时，C++将生成临时变量
 * --- 当且仅当参数为const引用时 ---
 *
 * 因此，编译器在实参和引用参数不匹配时，在下面两种情况会生成临时变量：
 * 1 实参的类型正确，但不是左值（左值：可以通过地址访问的变量都可称为左值）
 * 2 实参的类型不正确，但可以转换为正确的类型
 *
 * 此时编译器会生成一个临时匿名变量，并将引用形参指向该匿名变量。这些临时变量只在函数调用期间存在，此后编译器便可以随意将其删除
 *
 * */

#include <iostream>

void swap(int & a, int & b);
double cube(const double & a);

int main() {
    using namespace std;

    // 情形1：实参类型正确，但不是左值
    cout << "cube(3.0): " << cube(3.0) << "\n";// 此形参3.0不是左值

    // 情形2：类型不正确，但可以转换为正确的类型
    int c = 2;// 实参类型为int
    cube(c);
    cout << "new c: " << c << endl;

    // 下面解释：（在早期C++）
    // 为什么只有在const引用的情况下实参和形参不匹配才能work?--问题出在临时变量身上

    // 以下面为例子：
    long a = 1, b = 2;
    swap(a, b);

    cout << "new a: " << a << "\n" << "new b: " << b << endl;
};

// 以swap函数为例子，这里的形参不是const引用
// 当实参和形参类型不匹配时，编译器会创建临时变量，此时改变的变量就不是实参了，而是新创建的临时变量
// 而实际的参数（比如a和b）就没有变化
// 在本swap(int & a, int & b)函数中，被交换的是临时变量，而不是a和b，即a和b不变

// 解决的方法是：--禁止创建临时变量--现在的C++标准正是这样做的
void swap(int & a, int & b) {
    int temp;

    temp = a;
    a = b;
    b = temp;
}

// const引用，C++会在必要时（形参和实参不匹配）生成临时变量，使用临时变量来存储值--此时就相当于按值传递了。
double cube(const double & a) {// 常量引用参数
    return a * a *a;
}


